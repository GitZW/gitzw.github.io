---
layout:     post
title:      操作系统 学习笔记（二）
subtitle:   操作系统 学习笔记（二）
date:       2021-02-28
author:     ZW
header-img: img/mysql_img.jpg
catalog: 	 true
tags:
    - 操作系统
---


# 每个进程特点

1. 逻辑地址空间是一个抽象模型。
2. 保护独立地址空间。P1进程只能访问自己的地址空间，不能意外跨越去访问P2的地址空间；
3. 共享。进程P1, P2, … , 又是共享操作系统内核的
4. 虚拟化。每个进程的逻辑地址空间都是一致的，都是从地址0X0000开始。

# 内存管理方式
1. 重定位 relocation
2. 分段 segmentation
3. 分页 paging
4. 虚拟存储 virtual memory

目前大多数系统，如 Linux 采用按页式虚拟存储。

# 地址空间
物理地址空间----硬件支持的地址空间

逻辑地址空间----- 一个运行的程序所拥有的内存范围

逻辑地址生成：编译，汇编，链接，载入（程序重定位）

操作系统 建立逻辑地址和地址之间的映射

地址生成及处理过程：
>ALU需要逻辑地址中的内容（读或写），
MMU对逻辑地址进行转换，转换为物理地址，
CPU控制逻辑给总线发送物理地址请求。
内存发送物理地址的内容给CPU或者将CPU给的数据存储到物理地址。操作系统做的是简历逻辑地址LA和物理地址PA之间的映射。

地址检查：
>CPU执行到某条指令，得到它的逻辑地址，首先根据逻辑地址判断所在它的偏移量是否在所在段（比如数据段）的长度之内，如果超出了段长度，认为是非法请求，否则认为是合法的。此时加上段基址得到物理地址，进行访问。在这个过程中操作系统要做的就是设置段起始地址和最大逻辑地址空间（段长度）。

# 连续地址分配
## 内存碎片
内存碎片：有的还可以用，有的无论如何都用不起来了。

外部碎片：分配单元之间的未被使用内存

内部碎片：分配单元内部的未被使用内存（你只占500字节，但是不得不分配512字节）

## 分配策略
1. 最先匹配(First Fit Allocation)策略。
> 空闲分区列表按地址顺序排序
分配过程时，搜索一个合适的分区
释放分区时，检查是否可与临近的空闲分区合并

2. 最佳匹配(Best Fit Allocation)策略
> 空闲分区列表按照大小排序
分配时，查找一个合适的分区
释放时，查找并且合并临近的空闲分区（如果找到）


3. 最差匹配(Worst Fit Allocation)策略
> 空闲分区列表按由大到小排序
分配时，选最大的分区
释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序


## 碎片整理
### 碎片紧凑

实现方式：通过移动分配给进程的内存分区，以合并外部碎片。

条件：所有的应用程序可以动态重定位。这是因为程序中可能有很多地址引用，如果引用了绝对地址，移动分配的内存位置可能就会出错。因此需要动态重定位，执行到命令的时候才生成内存地址。

时机：进程处于等待状态时搬动。

开销：移动已分配的内存分区是有开销的，因此不会为了一小块碎片就进行紧凑。具体开销暂且按下不讲。

### 分区对换
>分区对换是通过抢占并回收处于等待状态进程的分区，以增大可用内存空间。即将等待状态进程的数据存储到外存中，也就是对换到对换区


## 伙伴系统
>伙伴系统是一个结合了2的方幂个分配器和空闲缓冲区合并计技术的内存分配方案, 其基本思想很简单. 内存被分成含有很多页面的大块, 每一块都是2个页面大小的方幂. 如果找不到想要的块, 一个大块会被分成两部分, 这两部分彼此就成为伙伴. 其中一半被用来分配, 而另一半则空闲. 这些块在以后分配的过程中会继续被二分直至产生一个所需大小的块. 当一个块被最终释放时, 其伙伴将被检测出来, 如果伙伴也空闲则合并两者


# 非连续内存分配

## 连续内存分配缺点
1. 分配给程序的物理内存必须连续

2. 存在外碎片和内碎片

3. 内存分配的动态修改困难

4. 内存利用效率低


## 非连续分配设计目标
提高内存利用效率和管理灵活性

允许一个程序的使用非连续的物理地址空间

允许共享代码与数据

支持动态加载和动态链接

## 如何实现虚拟地址和物理地址的转换

软件实现(灵活,开销大)

硬件实现(够用，开销小)


