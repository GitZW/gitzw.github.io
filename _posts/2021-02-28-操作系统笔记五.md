---
layout:     post
title:      操作系统 学习笔记（五）
subtitle:   操作系统 学习笔记（五）
date:       2021-02-28
author:     ZW
header-img: img/mysql_img.jpg
catalog: 	 true
tags:
    - 操作系统
---

# 同步互斥
背景
独立进程：不和其他进程共享资源或状态，具有确定性（输入决定结果）；可重现（能够重现起始条件）；调度顺序不重要。

并发进程：多个进程之间有资源共享；不确定性；不可重现。某些情况下调度的不一致会造成结果的不一致，也可能出现不可重现性。程序错误也可能是间歇性发生的。

## 利用原子操作实现一个锁。

### Lock.Acquire()
在锁被释放前一直等待，然后获得锁；

如果两个线程都在等待同一个锁，那如果锁被释放了，只有一个进程能得到锁
### Lock.Release()
解锁并唤醒任何等待中的进程。
#### 过程：
进入临界区

操作

退出临界区

#### 临界区访问规则：

空闲则入：没有进程在临界区时任何进程可以进入；
忙则等待：有进程在临界区，则其他进程均不能进入临界区；
有限等待：等待进入临界区的进程不能无线等待；
让权等待：不能进入临界区的进程，需要及时释放CPU

#### 基于软件的同步方法
软件方法：两个线程，T0和T1，线程可以通过共享一些共有变量来同步行为。

采用共享变量，设置一个共享变量表示允许进入临界区的线程；

设置一个共享变量数组，描述每个变量是否在临界区中，先判断另一个线程的flag是否是1，如果可以进入了，设置自己的flag；可能会同时等待或同时进入；

Peterson算法：turn表示该哪个进程进入临界区，flag[]表示进程是否准备好进入临界区。在进入区进程i要设置flag[i]=true，且turn=j，判断（flag[i] && turn==j），如果j没有申请进入，则i直接进去没问题。如果j也申请了，看谁先向trun里写数据，谁先写谁进入，由总线仲裁决定先后顺序！

N线程时，采用Eisenberg和McGuire算法，采用一个处理循环。

基于软件的方法很复杂，是一个忙等待


#### 自旋锁
当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -> 等待的机制被称为自旋锁(spinlock)

> 自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！
但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁。


# 信号量
多线程的引入导致了资源的竞争，同步是协调多线程对共享数据的访问，在任何时候只能有一个线程执行临界区代码。

信号量是操作系统提供的协调共享资源访问的方法，软件同步是平等线程间的一种同步协商机制。信号量是由OS负责管理的，OS作为管理者，地位高于进程。用信号量表示一类资源，信号量的大小表示资源的可用量。

信号量是一种抽象数据类型，由一个整型变量（共享资源数目）和两个原子操作组成。

PV 操作，P代表sem减一，V 代表sem 加一

信号量是被保护的整型变量，初始化完成后只能通过PV操作修改，是由操作系统保证PV操作是原子操作的。

