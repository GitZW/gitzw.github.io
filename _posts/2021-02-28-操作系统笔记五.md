---
layout:     post
title:      操作系统 学习笔记（五）
subtitle:   操作系统 学习笔记（五）
date:       2021-02-28
author:     ZW
header-img: img/mysql_img.jpg
catalog: 	 true
tags:
    - 操作系统
---

# 同步互斥
背景
独立进程：不和其他进程共享资源或状态，具有确定性（输入决定结果）；可重现（能够重现起始条件）；调度顺序不重要。

并发进程：多个进程之间有资源共享；不确定性；不可重现。某些情况下调度的不一致会造成结果的不一致，也可能出现不可重现性。程序错误也可能是间歇性发生的。

## 利用原子操作实现一个锁。

### Lock.Acquire()
在锁被释放前一直等待，然后获得锁；

如果两个线程都在等待同一个锁，那如果锁被释放了，只有一个进程能得到锁
### Lock.Release()
解锁并唤醒任何等待中的进程。
#### 过程：
进入临界区

操作

退出临界区

#### 临界区访问规则：

空闲则入：没有进程在临界区时任何进程可以进入；
忙则等待：有进程在临界区，则其他进程均不能进入临界区；
有限等待：等待进入临界区的进程不能无线等待；
让权等待：不能进入临界区的进程，需要及时释放CPU

#### 基于软件的同步方法
软件方法：两个线程，T0和T1，线程可以通过共享一些共有变量来同步行为。

采用共享变量，设置一个共享变量表示允许进入临界区的线程；

设置一个共享变量数组，描述每个变量是否在临界区中，先判断另一个线程的flag是否是1，如果可以进入了，设置自己的flag；可能会同时等待或同时进入；

Peterson算法：turn表示该哪个进程进入临界区，flag[]表示进程是否准备好进入临界区。在进入区进程i要设置flag[i]=true，且turn=j，判断（flag[i] && turn==j），如果j没有申请进入，则i直接进去没问题。如果j也申请了，看谁先向trun里写数据，谁先写谁进入，由总线仲裁决定先后顺序！

N线程时，采用Eisenberg和McGuire算法，采用一个处理循环。

基于软件的方法很复杂，是一个忙等待